@c Generated by doc-snarf, do not edit.

@c Copyright (C) 2012, 2013 Shane Celis <shane.celis@gmail.com>
@c Copyright (C) 2019 Jan (janneke) Nieuwenhuizen <janneke@gnu.org>

@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.3 or
@c any later version published by the Free Software Foundation; with no
@c Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
@c copy of the license is included in the section entitled ``GNU Free
@c Documentation License''.


@c snarfed from example/hello-emacsy.c:23

Let's exercise these functions in a minimal FreeGLUT program we'll call
@verb{|hello-emacsy|}.@footnote{Note: Emacsy does not rely on FreeGLUT.
One could use Gtk+, Ncurses, Qt, or whatever}.  This simple program
will display an integer, the variable @var{counter}, that one can
increment or decrement.

@image{images/minimal-emacsy-example,,,,.png}

@c snarfed from example/hello-emacsy.c:51

@defvar int counter = 0;
Hello Emacsy's state is captured by one global variable.
Hello Emacsy will display this number.
@end defvar

@c snarfed from example/hello-emacsy.c:60

Initialize everything in @var{main} and enter our runloop.

@c snarfed from example/hello-emacsy.c:67
@deftypefn {C Function}  glutInit (&argc, argv);
Initialize GLUT.
@end deftypefn

@c snarfed from example/hello-emacsy.c:77
@deftypefn {C Function}  void scm_init_guile ();
Initialize Guile.
@end deftypefn

@c snarfed from example/hello-emacsy.c:81
@deftypefn {C Function}  emacsy_initialize (@dots {});
Initialize Emacsy.
@end deftypefn

@c snarfed from example/hello-emacsy.c:91
@deftypefn {C Function}  primitives_init ();
Register primitives.
@end deftypefn

@c snarfed from example/hello-emacsy.c:96
@deftypefn {C Function}  char * try_load_startup (@dots{});
Try to load @file{hello-emacsy.scm}
@end deftypefn

@c snarfed from example/hello-emacsy.c:112
@deftypefn {C Function}  void glutMainLoop ();
Enter GLUT main loop, not return.
@end deftypefn

@c snarfed from example/hello-emacsy.c:119

@subsection Runloop Interaction

Let's look at how Emacsy interacts with your application's runloop
since that's probably the most concerning part of embedding.  First,
let's pass some input to Emacsy.

@c snarfed from example/hello-emacsy.c:127
@deftypefn {C Function}  void keyboard_func (unsigned char glut_key, int x, int y)
Send key events to Emacsy.
@end deftypefn

@c snarfed from example/hello-emacsy.c:133

int key; // The Key event (not processed yet).

@c snarfed from example/hello-emacsy.c:153

The keys @verb{|C-a|} and @verb{|C-b|} return @code{1} and @code{2}
respectively.  We want to map these to their actual character values.

@c snarfed from example/hello-emacsy.c:164
@deftypefn {C Function}  void display_func ()
The function @var{display_func} is run for every frame that's
drawn. It's effectively our runloop, even though the actual runloop is
in FreeGLUT.

Our application has just one job: Display the counter variable.
@end deftypefn

@c snarfed from example/hello-emacsy.c:174
@deftypefn {C Function}  glClear (GL_COLOR_BUFFER_BIT);
Setup the display buffer the drawing.
@end deftypefn

@c snarfed from example/hello-emacsy.c:193

Process events in Emacsy.

@c snarfed from example/hello-emacsy.c:203

Display Emacsy message/echo area.

@c snarfed from example/hello-emacsy.c:208

Display Emacsy mode line.

@c snarfed from example/hello-emacsy.c:216
@deftypefn {C Function}  void draw_string (int x, int y, char *string)

Draw a string function.
Draws a string at (x, y) on the screen.
@end deftypefn

@c snarfed from example/hello-emacsy.c:232

At this point, our application can process key events, accept input on
the minibuffer, and use nearly all of the facilities that Emacsy
offers, but it can't change any application state, which makes it not
very interesting yet.

@c snarfed from example/hello-emacsy.c:239

@subsection Plugging Into Your App

@c snarfed from example/hello-emacsy.c:245

@deffn {Scheme Procedure} get-counter
@deffnx {C Function} SCM scm_get_counter ()
Let's define a new primitive Scheme procedure @var{get-counter}, so
Emacsy can access the application's state.  This will define
a @var{C} function @code{SCM scm_get_counter (void)} and a Scheme procedure
@code{(get-counter)}.

@end deffn

@c snarfed from example/hello-emacsy.c:266

@deffn {Scheme Procedure} set-counter! value
@deffnx {C Function} SCM scm_set_counter_x (SCM value)
Let's define another primitive Scheme procedure to alter the
application's state.
@end deffn

@c snarfed from example/hello-emacsy.c:285
@deftypefn {C Function}  void primitives_init ()
Once we have written these primitive procedures, we need to register
them with the Scheme runtime.
@end deftypefn

@c snarfed from example/hello-emacsy.c:297
@deftypefn {C Function}  char * try_load_startup (char const* prefix, char const* dir, char const* startup_script)
Locate the @file{hello-emacsy.scm} Guile initialization and load it.
@end deftypefn

@c snarfed from example/hello-emacsy.scm:20
We generate the file @file{example/hello-emacsy.c.x} by running the
command: @code{guile-snarf example/hello-emacsy.c}.  Emacsy can now
access and alter the application's internal state.

@c snarfed from example/hello-emacsy.scm:30
@deffn {Interactive Procedure} incr-counter  #:optional (n (universal-argument-pop!))
@kindex incr-counter  #:optional (n (universal-argument-pop!))

@end deffn

@c snarfed from example/hello-emacsy.scm:34
@deffn {Interactive Procedure} decr-counter  #:optional (n (universal-argument-pop!))
@kindex decr-counter  #:optional (n (universal-argument-pop!))

@end deffn

@c snarfed from example/hello-emacsy.scm:38
@deffn {Scheme Procedure} global-map
Bind @var{inc-counter} to @code{=}.
@end deffn

@c snarfed from example/hello-emacsy.scm:40
@deffn {Scheme Procedure} global-map
Bind @var{inc-counter} to @code{-}.
@end deffn

@c snarfed from example/hello-emacsy.scm:49
Let's implement another command that will ask the user for a number to
set the counter to.

@c snarfed from example/hello-emacsy.scm:53
@deffn {Interactive Procedure} change-counter
@kindex change-counter
Now we can hit @verb{|M-x change-counter|} and we'll be prompted for
the new value we want.  There we have it.  We have made the simplest
application ever more @emph{Emacs-y}.
@end deffn

@c snarfed from example/hello-emacsy.scm:61
We can add commands easily by changing and reloading the file.  But
we can do better.  Let's start a REPL we can connect to.
@file{example/hello-emacsy.scm}.

@c snarfed from example/hello-emacsy.scm:66
@example
(use-modules (system repl server))
(spawn-server)
@end example
Start a server on port 37146.
